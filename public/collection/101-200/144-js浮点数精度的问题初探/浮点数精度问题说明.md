很多语言中都有浮点数数据精度的问题 JavaScript 中也是
例如：0.1 + 0.2 应该等于 0.3 但结果 事实上是 0.30000000004
原因：

- 小数转换成二进制的方法：
  将小数部分先乘以 2，记录整数部分，然后将得到的结果的小数部分乘以 2，记录整数部分，直到乘法得到的结果是整数 1 时停止。
- 实例：0.1 的二进制计算方法如下

  ```txt
  0.1*2=0.2 0
  0.2*2=0.4 0
  0.4*2=0.8 0
  0.8*2=1.6 1
  0.6*2=1.2 1
  0.2*2=0.4 0
  0.4*2=0.8 0
  0.8*2=1.6 1
  0.6*2=1.2 1
  0.2*2=0.4 0
  0.4*2=0.8 0
  0.8*2=1.6 1
  0.6*2=1.2 1
  0.2*2=0.4 0
  0.4*2=0.8 0
  0.8*2=1.6 1
  0.6*2=1.2 1
  0.2*2=0.4 0
  0.4*2=0.8 0
  .........
  ```

因此 0.1 的二进制表示是无穷的 0.0001100110011001100110011
在 JavaScript 中是以双精度(64)位来保存浮点数，多余的部分会被截取掉，
而实际 0.1 在 JavaScript 中存储的是 0.00011001100110011001100110011001100110011001100110011001100
我们看到的是 0.1 已经不是 0.1 了，而是一个很长的二进制数据，所以计算的时候会存在误差。

- 简单的总结
  二进制表示浮点数 0.1 是无限循环的但是因为内存有限计算时只能截取一定长度就导致了计算的精度丢失，
  就像十进制表示 1/3 一样 1/3 转成十进制是 0.3333...一样转成 三个 1/3 本来是 1 但是三个 0.3333...确只能等于 0.9999..

- 消除误差的主要方法：
  1、使用 round() 函数指定小数点位数
  2、使用 [bignumber.js](https://www.npmjs.com/package/bignumber.js) 将浮点数包装
